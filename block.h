#ifndef BLOCK_H_INCLUDED
#define BLOCK_H_INCLUDED

int blocks[7][4][4][2] = {
    {{{0,-2},{0,-1},{0,0},{0,1}},{{-2,0},{-1,0},{0,0},{1,0}},{{0,-2},{0,-1},{0,0},{0,1}},{{-2,0},{-1,0},{0,0},{1,0}}},// I
    {{{0,-1},{0,0},{1,0},{1,-1}},{{-1,0},{0,0},{0,-1},{1,-1}},{{0,-1},{0,0},{1,0},{1,-1}},{{-1,0},{0,0},{0,-1},{1,-1}}}, // Z
    {{{0,1},{0,0},{1,0},{1,-1}},{{-1,-1},{0,-1},{0,0},{1,0}},{{0,1},{0,0},{1,0},{1,-1}},{{-1,-1},{0,-1},{0,0},{1,0}}}, // Z
    {{{1,0},{0,-1},{0,0},{0,1}},{{-1,0},{0,-1},{0,0},{1,0}},{{0,-1},{0,0},{-1,0},{0,1}},{{0,1},{-1,0},{0,0},{1,0}}}, // T
    {{{1,-1},{0,-1},{0,0},{0,1}},{{-1,0},{-1,-1},{0,0},{1,0}},{{0,-1},{0,0},{-1,1},{0,1}},{{1,1},{-1,0},{0,0},{1,0}}}, // L
    {{{1,1},{0,-1},{0,0},{0,1}},{{-1,0},{1,-1},{0,0},{1,0}},{{0,-1},{0,0},{-1,-1},{0,1}},{{-1,1},{-1,0},{0,0},{1,0}}}, // J
    {{{0,0},{0,1},{1,0},{1,1}},{{0,0},{0,1},{1,0},{1,1}},{{0,0},{0,1},{1,0},{1,1}},{{0,0},{0,1},{1,0},{1,1}}} // square
};

class block{

public:
    int statu;
    int code;

    block(){
        statu = 0;
        code = std::rand()%7;
    }
    void newBlock(){
        statu = 0;
        code = std::rand()%7;
    }
    block& operator = (const block& anotherBlock) {
        this->statu = anotherBlock.statu;
        this->code = anotherBlock.code;
        return *this;
    }
};


#endif // BLOCK_H_INCLUDED
